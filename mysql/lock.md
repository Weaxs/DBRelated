> # 锁

当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录相关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。

> 锁结构的主要信息

    trx信息      代表这个锁结构是哪个事务生成的
    is_waiting  代表当前事务是否在等待
    
1. 获取(加)锁成功  
当事务T1改动了这条记录，就生成一个锁结构与该记录关联，因为之前没有别的事务对这条记录加锁，所以is_waiting属性是false，这个场景称之为 获取锁成功 或者 加锁成功。
2. 获取(加)锁失败   
当事务T2也想对该记录做改动，就先去看看有没有锁结构与这条记录关联，发现一个锁结构与之关联后，也生成一个锁结构与这条记录关联，但是is_waiting属性值为true，表示当前事务需要等待，这个场景称之为 获取锁失败 或者 加锁失败。
3. 不加锁  
不需要在内存中生成对应的锁结构，可以直接执行操作

> 解决脏读、不可重复读、幻读的两种方案

    1. 读操作利用多版本并发控制 (MVCC), 写操作进行加锁
        MVCC是通过生成一个ReadView，通过它来找到符合条件的记录版本，查询语句只能读到在生成ReadView前已提交事务所做的更改，在生成ReadView前未提交的事务是看不到的
        写操作时针对最新版本的记录，读记录的历史版本和写操作本身并不冲突，故采用MVCC时，读-写并不冲突
    2. 读、写操作都采用加锁的方式
        在一些场景中不允许读取记录的旧版本，每次必须读取记录的最新版本
        此时读取记录的时候也需要对其进行加锁操作，这样就以为这读操作和写操作箱写-写操作那样排队执行

    总结：
    1.在普通的SELECT语句的READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录
        在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读取到未提交的事务所做的更改(避免脏读)
        在REPEATABLE READ隔离级别下，一个事务只有在第一次执行SELECT操作才会生成一个ReadView，之后的Select都复用这个ReadView(避免不可重复读+幻读)
    2.一般情况下采用MVCC+写加锁的方式来解决读-写操作并发执行的问题
      但在某些特殊情况下，要求必须采用读写均加锁的方式执行

> 一致性读 (Consistent Reads)

    事务利用MVCC进行的读取操作成为一致性读，或者一致性无读锁，或者快照锁
    普通的SELECT语句(plain SELECT)在READ COMMITTED、REPEATABLE READ隔离级别下都算是一致性读
    
> 锁定读 (Locking Reads)

    共享锁(Shared Locks)S锁          允许其他事务进行读操作，不允许写操作 (在事务读取一条记录时，需要先获取该记录的S锁)
    独占锁(Exclusive Locks 排它锁)X锁  不允许其他事务进行写/读操作 (在事务改动一条记录时，需要先获取该记录的X锁)
        兼容性	    X	    S
          X	      不兼容	  不兼容
          S	      不兼容	   兼容
    
    对读取的记录加S锁：(注，获取某条记录的X锁时，也需要等待已经加的S锁先执行完释放掉)
        SELECT ... LOCK IN SHARE MODE
    对读取的记录加X锁：
        SELECT ... FOR UPDATE
     
     意向共享锁，英文名：Intention Shared Lock，简称IS锁。当事务准备在某条记录上加S锁时，需要先在表级别加一个IS锁。
     意向独占锁，英文名：Intention Exclusive Lock，简称IX锁。当事务准备在某条记录上加X锁时，需要先在表级别加一个IX锁。
     IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁,以避免用遍历的方式来查看表中有没有上锁的记录
     也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。
     
> InnoDB中的行级锁  
行锁，也称为记录锁，顾名思义就是在记录上加的锁。

    1.Record Locks(记录锁) LOCK_REC_NOT_GAP
        记录锁是分为S锁和X锁
    2.Gap Locks(间隙锁) LOCK_GAP
        gap锁的提出仅仅是为了防止插入幻影记录而提出的，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。
        当对一条记录加了gap锁，并不影响对该记录添加记录锁
        给一条记录加了gap锁不允许其他事务往这条记录前边的间隙插入新记录
    3.Next-Key Locks(next-key锁)LOCK_ORDINARY
        一个记录锁 + 一个间隙锁
        既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。
        REPEATABLE READ隔离级别下的S锁和X锁默认都是Next-Key Locks
        加锁规则包含了两个“原则”、两个“优化”和一个“bug”。
            原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
            原则 2：查找过程中访问到的对象才会加锁。
            优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
            优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
            一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
        lock in share mode 只锁覆盖索引
        for update 系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。
    4.Insert Intention Locks(插入意向锁)LOCK_INSERT_INTENTION
        一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁，如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。
        在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，这个锁结构就是插入意向锁
        插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁
    5.隐式锁
        一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于事务id这个牛逼的东东的存在，相当于加了一个隐式锁。
        别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个X锁，然后自己再生成一个锁结构后进入等待状态。

> InnoDB中的表级锁

     1.表级别的IS锁、IX锁
        当我们在对使用InnoDB存储引擎的表的某些记录加S锁之前，那就需要先在表级别加一个IS锁。
        当我们在对使用InnoDB存储引擎的表的某些记录加X锁之前，那就需要先在表级别加一个IX锁。
        IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。
     2.表级别的AUTO-INC锁
     A  UTO-INC锁的作用范围只是单个插入语句，插入语句完成锁被释放，而非一个事务
        一个事务在持有AUTO-INC锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。
        
        
        
