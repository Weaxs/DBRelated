> #MySQL基础简要介绍

> MySQL事务

    原子性 (Atomicity):事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
    一致性 (Consistency):执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
    隔离性 (Isolation):并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    持久性 (Durability):一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
    
> MySQL并发问题

    脏读 (Dirty read):当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
    丢失修改 (Lost to modify):指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
    不可重复读 (Unrepeatableread):指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
    幻读 (Phantom read):幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据，接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现多了/少了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
    
> MySQL事务隔离级别

    READ-UNCOMMITTED(读取未提交):最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
    READ-COMMITTED(读取已提交):允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
    REPEATABLE-READ(可重复读):对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
    SERIALIZABLE(可串行化):最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
    
    MySQL InnoDB存储引擎的默认支持的隔离级别是REPEATABLE-READ(可重读)
    与SQL标准不同的地方在于 InnoDB存储引擎在REPEATABLE-READ(可重读)事务隔离级别下使用的是Next-Key Lock锁算法，因此可以避免幻读的产生
    
> 锁机制 与 InnoDB锁

    根据锁的类型分为:
        共享锁(读锁 S锁 Shared Locks):一个事务执行时，其他事务可以读但是不能写
        排它锁(写锁 X锁 Exclusive Locks):一个事务执行时，其他事务不能读也不能写
    对读取的记录加S锁:
        SELECT ... LOCK IN SHARE MODE;
    对读取的记录加X锁:
        SELECT ... FOR UPDATE;
    
    根据锁的粒度分为:
        表级锁:对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低。
        行业锁:只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。
        页面锁:介于表级锁和行级锁之间
    
    
    InnoDB存储引擎的锁的算法有三种:
        Record lock:单个行记录上的锁
        Gap lock:间隙锁, 锁定一个范围, 不包括记录本身
        Next-key lock: Record+Gap 锁定一个范围, 包含记录本身
        
> MVCC 多版本并发控制 (Multi-Version Concurrency Control)

    在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SELECT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行
    对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。
    
    对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列:
        trx_id:每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
        roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
    
    在执行UPDATE/DELETE的操作时，会把trx_id改为当前事务id 把roll_pointer指向修改前的信息形成版本链
    在执行INSERT的操作时，会把trx_id赋值当前事务id，并生成undo日志，但undo日志没有roll_pointer属性，因为它没有修改前的值
    在执行SELECT的操作时，引入ReadView的概念:
        ReadView中主要包含4个比较重要的内容：
        m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
        min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
        max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
        creator_trx_id：表示生成该ReadView的事务的事务id。
    按照下边的步骤判断记录的某个版本是否可见：
        如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
        如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
        如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
        如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。
    比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。
    在一个只读事务中的事务id值都默认为0。
    
    READ COMMITTD(读取已提交)在每一次进行普通SELECT操作前都会生成一个ReadView;
    REPEATABLE READ(可重复读)只在第一次进行普通SELECT操作前生成一个ReadView, 之后的查询操作都重复使用这个ReadView就好了, 保证两次SELECT查询得到的结果是重复的。
    
> MySQL执行过程
    
    MySQL分为 Server层 和 存储引擎层 
    Server层:主要包括连接器、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
    存储引擎:主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。

    Server层相关组件:
    连接器:身份认证和权限相关(登录 MySQL 的时候)。
    分析器:词法分析+语法分析。
    优化器:按照 MySQL 认为最优的方案去执行。
    执行器:执行语句，然后从存储引擎返回数据。 

> 索引

    两种数据结构: Hash索引  和  B+树索引
    
    主键索引:数据表的主键列使用的就是主键索引。如果建表没有索引, InnoDB将会自动创建一个6Byte的自增主键。
    二级索引(辅助索引):二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
                    唯一索引，普通索引，前缀索引等索引属于二级索引。
                    唯一索引(Unique Key):唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为NULL。
                    普通索引(Index):普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。
                    前缀索引(Prefix):前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引, 相比普通索引建立的数据更小, 因为只取前几个字符。
                    全文索引(Full Text):全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。
                    
    聚集索引:聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
    非聚集索引:非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据(回表)。
    
    回表查询:先通过非聚集索引树, 查询主键的值，再根据聚集索引树查出具体的数据。
    覆盖索引:需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。
    
    索引下堆(ICP, Index Condition Pushdown)
        某一个索引对一个特定的表从表中获取元祖
        通俗的说，MySQL在取出索引的同时，判断是否可进行where条件过滤再进行索引查询，提前执行where部分过滤，大大减少回表次数
    
    单列索引:单列索引即由一列属性组成的索引。
    联合索引(多列索引):联合索引即由多列属性组成索引。
    
> 日志
    
    
    
    
> 分库分表
    
    分表
    就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。
    分库
    将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。
    
    水平拆分:保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
            将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。
    垂直拆分:根据数据库里面数据表的相关性进行拆分。简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。
            一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。
    range拆分:每个库一段连续的数据，这个一般是按比如时间范围来的。但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。
            扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。
    hash拆分:按照某个字段 hash 一下均匀分散。
            可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。
            
    分库分表后主键的处理方式:
        snowflake 雪花算法
            一个 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bits 作为毫秒数，用 10 bits 作为工作机器 id，12 bits 作为序列号
            1 bit：我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
            41 bits：表示的是时间戳，单位是毫秒。41 bits 可以表示的数字多达 2^41 - 1 ，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。
            10 bits：记录工作机器 id，代表的是这个服务最多可以部署在 2^10 台机器上，也就是 1024 台机器。但是 10 bits 里 5 个 bits 代表机房 id，5 个 bits 代表机器 id。意思就是最多代表 2^5 个机房（32 个机房），每个机房里可以代表 2^5 个机器（32台机器）。
            12 bits：这个是用来记录同一个毫秒内产生的不同 id，12 bits 可以代表的最大正整数是 2^12 - 1 = 4096 ，也就是说可以用这个 12 bits 代表的数字来区分同一个毫秒内的 4096 个不同的 id。
        
> 读/写分离

    基于主从复制架构，主库会自动把数据给同步到从库上去。
    
    MySQL 主从复制原理
    主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。
    1.半同步复制 (semi-sync复制)
        主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。
    2.并行复制
        从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。
    