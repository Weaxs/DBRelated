> # Redis基础简要介绍

>Redis支持的数据类型

    1.stirng 字符串
    String 数据结构是简单的 key-value 类型，value 其实不仅可以是 String，也可以是数字。
    Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改。除了记录值的功能外，如果 value 是一个整数，还可以对它使用 INCR 命令进行原子性的自增操作。
    常见用途： key-value 缓存应用； 常规计数：微博数，粉丝数等。
    
    2.list 列表
    Redis list 的实现为一个双向链表。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)。
    可以通过 list 实现队列/栈，还可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询。
    常见用途：基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。
    
    3.hash 字典
    hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象, 类似于Map, 通过 "数组 + 链表" 的链地址法来解决部分哈希冲突.
    字典结构的内部包含两个 hashtable，通常情况下只有一个 hashtable 是有值的, 另一个用于字典扩容缩容。
    hash扩容方式 —— 渐进式 rehash 小步搬迁：
    渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 hash 操作指令中，循序渐进的把旧字典的内容迁移到新字典中。当搬迁完成了，就会使用新的 hash 结构取而代之。
    常见用途：存储用户信息
    
    4.set 集合
    Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。
    当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口。
    可以基于 set 轻易实现交集、并集、差集的操作。
    常见用途：共同关注、共同粉丝、共同喜好等功能。将其所有粉丝存在一个集合。
    
    5.Sorted Set (ZSet) 有序集合
    和 set 相比，sorted set 增加了一个权重参数 score。一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。
    它的内部实现用的是一种叫做 「跳跃表」 的数据结构。
    常见用途： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息
    
> Redis过期时间 ( expire time )

    Redis 中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。
    
    过期时间的删除：定期删除+惰性删除
    定期删除：redis 默认是每隔100ms就 随机 抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
    惰性删除：假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被 redis 给删除掉。
  
> Redis 内存淘汰机制

    Redis提供8种数据淘汰策略，防止在定期+惰性删除后存在大量过期key
    1.volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
    2.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
    3.volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
    4.allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
    5.allkeys-random：从数据集中任意选择数据淘汰
    6.no-eviction：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错
    7.volatile-lfu：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
    8.allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key
    
> Redis持久化机制

    Redis的数据全部存储在内存中，重启/宕机后内存中的数据全部就会丢失。
    
    1.快照（snapshotting）持久化（RDB）
    当满足特定条件时，它将生成数据集的时间点快照，例如，如果先前的快照是在2分钟前创建的，并且现在已经至少有100次新写入，则将创建一个新的快照。
    Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。
    Redis使用系统多进程COW(Copy On Write)机制 产生一个子进程，快照持久化完全交给子进程处理, 父进程则继续处理客户端请求。子进程只进行读，父进程进行读写。
    这个时候就会使用操作系统的COW机制来进行 数据段页面的分离。数据段是由很多操作系统的页面组合而成，当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份分离出来，然后 对这个复制的页面进行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据。
   
    2.AOF（append-only file）持久化
    开启AOF持久化后每每次执行修改内存中数据集的写操作时，Redis就会将该命令写入硬盘中的AOF文件。
    假设AOF日志记录了自Redis实例创建以来所有的修改性指令序列，那么就可以通过对一个空的Redis实例顺序执行所有的指令，也就是「重放」，来恢复 Redis当前实例的内存数据结构的状态。
    当 Redis收到客户端修改指令后，会先进行参数校验、逻辑处理，如果没问题，就立即将该指令文本存储到AOF日志中，也就是说，先执行指令再将日志存盘。 —— 提交执行后写日志  
    原因：可能是由于语法级别检查并不能保证指令的有效性，只能先执行后写日志，比如删除不存在的数据。但会导致写日志中断时数据的丢失。
    AOF重写：Redis 在长期运行的过程中，AOF 的日志会越变越大，以此来对AOF文件"瘦身"。
    开辟一个子进程对内存进行遍历转换成一系列 Redis 的操作指令，序列化到一个新的AOF日志文件中。序列化完毕后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就立即替代旧的AOF日志文件了，瘦身工作就完成了。(相当于去掉了删除和修改, 只剩新增操作)
    AOF写入的三种方式
    appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
    appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘 —— 默认
    appendfsync no        #让操作系统决定何时进行同步，不安全
    
    3.Redis 4.0 混合持久化
    重启Redis时，我们很少使用rdb来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重放，但是重放AOF日志性能相对rdb来说要慢很多, 在此场景下，添加了混合持久化。
    顾名思义就是, 将rdb文件的内容和增量的AOF日志文件存在一起。这里的AOF日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量AOF日志，通常这部分AOF日志很小：
    于是在Redis重启的时候，可以先加载rdb的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率因此大幅得到提升。
    
> Redis部署方式
    
    1.单机模式
    部署一个Redis实例
    受限于单核CPU的处理能力（Redis是单线程机制）, 不保证数据的可靠性等等
    
    2.主从模式
    Redis多副本，采用主从（replication）部署结构，相较于单副本而言最大的特点就是主从实例间数据实时同步，并且提供数据持久化和备份策略。可以实现读写分离。
    Redis提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。
    当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从**。复制初始化结束。
    之后，主每收到1个命令就同步发送给从 (异步)。
    
    3.哨兵模式 (Redis Sentinel集群)
    当主数据库遇到异常中断服务后，开发者可以通过手动的方式/通过选举从从服务器中选择一个从数据库来升格为主数据库，以使得系统能够继续提供服务。
    每个sentinel会向其它sentinal、master、slave定时发送消息，以确认对方是否“活”着，
        若发现对方在指定时间（可配置）内未回应，则暂时认为对方已挂（所谓的“主观认为宕机” Subjective Down，简称SDOWN）。
        若“哨兵群”中的多数sentinel，都报告某一master没响应，系统才认为该master"彻底死亡"(即：客观上的真正down机，Objective Down，简称ODOWN)
    通过一定的vote算法，从剩下的slave节点中，选一台提升为master，然后自动修改相关配置。
    问题以及解决：
        异步复制导致的数据丢失
            因为 master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。
            解决：min-slaves-max-lag 命令 以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内。
        脑裂导致的数据丢失
            某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master。这个时候，集群里就会有两个master，也就是所谓的脑裂。
            此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续向旧master写数据。因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据。而新的master并没有后来 client 写入的数据，因此，这部分数据也就丢失了。
            解决：min-slaves-max-lag y 命令 和 min-slaves-to-write x 命令  要求至少有 x 个 slave，数据复制和同步的延迟不能超过 y 秒。
            如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过y秒没有给自己ack消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失y秒的数据。
    slave->master 选举算法
        如果一个master被认为odown了，而且majority数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来，会考虑slave的一些信息：
        跟 master 断开连接的时长 (哪个和master断开时间短，优先级越高)
        slave 优先级           (slave priority 越低，优先级就越高)
        复制 offset           (replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高)
        run id               (选择一个run id比较小的)
    
    4.集群模式 (cluster-enable)
    Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。
    集群模式和哨兵模式的区别在于：
        哨兵模式下，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。
        但集群模式下，每台redis存储不同的内容。
    Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。
    集群模式下如何找key对应的服务器：
        分布式寻址算法： hash算法(大量缓存重建)   一致性hash算法(自动缓存迁移)+虚拟节点(自动负载均衡)   Redis cluster的hash slot算法
    判断节点宕机及选举算法，同哨兵模式类似
    
    
>缓存雪崩 缓存穿透 缓存击穿
    
    缓存雪崩
        缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
    解决办法：
        事前：尽量保证整个redis集群的高可用性，发现机器宕机尽快补上 (哨兵模式)。选择合适的内存淘汰策略。
        事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 崩掉
        事后：利用 redis 持久化机制保存的数据尽快恢复缓存
    
    缓存穿透
        大量请求的key根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。
    解决办法：
        1.每次系统A从数据库中只要没查到，就写一个空值到缓存里去，然后设置一个过期时间，这样的话，下次有相同的key来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。
        2.做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。
        3.布隆过滤器
        
    缓存击穿
        某个key非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。
    解决办法：
        1.若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
        2.若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于Redis、zookeeper等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
        3.若缓存的数据更新频繁或者在缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。
        
> Redis 的并发竞争 Key 问题

    基于zookeeper实现分布式锁。每个系统通过zookeeper获取分布式锁，确保同一时间，只能有一个系统实例在操作某个key，别人都不允许读和写。

> 缓存与数据库的双写一致性
    
    最经典的缓存+数据库读写的模式 Cache Aside Pattern    
        读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
        更新的时候，先更新数据库，然后再删除缓存。
    问题一：存在删除缓存失败的情况，导致不一致
    解决：改为先删除缓存，再更新数据库。即便更新数据库失败，读也是读数据库的数据。
    问题二：在更新数据库未提交时，另一个线程进来读取了旧数据并反写给缓存，造成不一致
    解决：根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。(串行化)
    
    
    
        
